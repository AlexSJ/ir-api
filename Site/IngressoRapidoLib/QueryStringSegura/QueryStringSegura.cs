using System;
using System.Collections.Specialized;
using System.Text;

namespace IngressoRapido.QueryStringSegura
{
	/// <summary>
	/// Provides a secure means for transfering data within a query string.
	/// </summary>
	public class QueryStringSegura : NameValueCollection
	{
        const string timeStampKey = "__TS__";
        //const string dateFormat = "dd/MM/yyyy HH:mm:ss";
        //const string dateFormat = "MM/dd/yyyy HH:mm:ss";
        const string dateFormat = "G";
        
        ISymmetricCryptoProvider symmetricCryptoProvider;
        IHashProvider hashProvider;
        //DateTime expireTime = DateTime.MaxValue;
        DateTime expireTime = DateTime.ParseExact("20500101", "yyyyMMdd", null);

        byte[] key;

        /// <summary>
        /// Creates an instance with a specified key.
        /// </summary>
        /// <param name="key">The key used for cryptographic functions.</param>
        public QueryStringSegura(byte[] key) : base()
        {
            symmetricCryptoProvider = new SymmetricAlgorithmProvider(key);
            hashProvider = new HashAlgorithmProvider();
            this.key = key;
        }

        /// <summary>
        /// Creates an instance with a specified key and an encrypted query string.
        /// </summary>
        /// <param name="key">The key used for cryptographic functions.</param>
        /// <param name="queryString">An encrypted query string generated by a <see cref="SecureQueryString"/> instance.</param>
        public QueryStringSegura(byte[] key, string queryString) : this(key)
        {
            Deserialize(DecryptAndVerify(queryString));
            CheckExpiration();
        }

        /// <summary>
        /// Gets or sets the timestamp in which this string should expire
        /// </summary>
        public DateTime ExpireTime 
        {
            get { return expireTime; }
            set { expireTime = value; }
        }

        /// <summary>
        /// Gets or sets the symmetric cryptography provider to use for cryptographic functions.
        /// </summary>
        /// <remarks>
        /// Changing this value will result in different output. The provider must use the same
        /// underlying symmetric algorithm for generating and retrieving query strings.
        /// </remarks>
        public ISymmetricCryptoProvider SymmetricCryptoProvider 
        {
            get { return symmetricCryptoProvider; }
            set { symmetricCryptoProvider = value; }
        }

        /// <summary>
        /// Gets or sets the hash provider to use for hashing functions.
        /// </summary>
        /// <remarks>
        /// Changing this value will result in different output. Thet provider must use the same
        /// underlying hash algorithm for generating and retrieving query strings.
        /// </remarks>
        public IHashProvider HashProvider 
        {
            get { return hashProvider; }
            set { hashProvider = value; }
        }

        /// <summary>
        /// Returns a encrypted query string.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return EncryptAndSign(Serialize());
        }

        private void Deserialize(string queryString) 
        {
            string[] nameValuePairs = queryString.Split('&');
            for (int i=0; i < nameValuePairs.Length; i++) 
            {
                string[] nameValue = nameValuePairs[i].Split('=');
                if (nameValue.Length == 2) 
                {
                    base.Add(nameValue[0], nameValue[1]);
                }
            }

            //if (base[timeStampKey] != null) expireTime = DateTime.ParseExact(base[timeStampKey],dateFormat,null);
        }

        private string Serialize()
        {
            StringBuilder sb = new StringBuilder();
            foreach (string key in base.AllKeys) 
            {
                sb.Append(key);
                sb.Append('=');
                sb.Append(base[key]);
                sb.Append('&');
            }

            sb.Append(timeStampKey);
            sb.Append('=');
            sb.Append(expireTime.ToString(dateFormat));

            return sb.ToString();
        }

        private string DecryptAndVerify(string input) 
        {
            byte[] plainText = null;
            
            try 
            {
                byte[] inputBytes = Convert.FromBase64String(input);
                
                byte hashLength = inputBytes[0];
                byte[] hash = new byte[hashLength];
                Buffer.BlockCopy(inputBytes, 1, hash, 0, hashLength);
                byte[] cipherText = new byte[inputBytes.Length - hashLength - 1];
                Buffer.BlockCopy(inputBytes, hashLength + 1, cipherText, 0, cipherText.Length);
                byte[] compareHash = hashProvider.Hash(CombineBytes(key, cipherText));
                
                if (!CommonUtil.CompareBytes(hash, compareHash)) 
                {
                    throw new InvalidQueryStringException("Query string was improperly signed or tampered with");    
                }
                
                plainText = symmetricCryptoProvider.Decrypt(cipherText);
            } 
            catch (Exception) 
            {
                throw new InvalidQueryStringException();
            } 
            
            return Encoding.Unicode.GetString(plainText);
        }

        private string EncryptAndSign(string input) 
        {
            byte[] cipherText = symmetricCryptoProvider.Encrypt(Encoding.Unicode.GetBytes(input));
            byte[] hash = hashProvider.Hash(CombineBytes(key, cipherText));
            byte[] signedBytes = CombineBytes(hash, cipherText);
            byte[] hashLength = new byte[] {(byte)hash.Length};
            
            return Convert.ToBase64String(CombineBytes(hashLength, signedBytes));
        }

        private void CheckExpiration() 
        {
            if (DateTime.Compare(ExpireTime, DateTime.Now) < 0) 
            {
                throw new ExpiredQueryStringException();
            }
        }

        private byte[] CombineBytes(byte[] buffer1, byte[] buffer2) 
        {
            byte[] combinedBytes = new byte[buffer1.Length + buffer2.Length];
            Buffer.BlockCopy(buffer1, 0, combinedBytes, 0, buffer1.Length);
            Buffer.BlockCopy(buffer2, 0, combinedBytes, buffer1.Length, buffer2.Length);

            return combinedBytes;
        }
	}
}
